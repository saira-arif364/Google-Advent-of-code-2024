# -*- coding: utf-8 -*-
"""Day 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jzLyLVsMazC0VfjuVmwoRmqmsjw3XHGi
"""

def read_map(file_path):
    with open(file_path, 'r') as file:
        return [list(line.strip()) for line in file]

def guard_patrol(grid):
    directions = {'^': (-1, 0), '>': (0, 1), 'v': (1, 0), '<': (0, -1)}
    direction_order = ['^', '>', 'v', '<']

    # Find the guard's starting position and facing direction
    for r, row in enumerate(grid):
        for c, cell in enumerate(row):
            if cell in directions:
                guard_pos = (r, c)
                guard_dir = cell
                break

    visited = set()
    rows, cols = len(grid), len(grid[0])

    while 0 <= guard_pos[0] < rows and 0 <= guard_pos[1] < cols:
        visited.add(guard_pos)

        dr, dc = directions[guard_dir]
        next_pos = (guard_pos[0] + dr, guard_pos[1] + dc)

        if 0 <= next_pos[0] < rows and 0 <= next_pos[1] < cols and grid[next_pos[0]][next_pos[1]] == '#':
            # Turn right 90 degrees
            guard_dir = direction_order[(direction_order.index(guard_dir) + 1) % 4]
        else:
            # Move forward
            guard_pos = next_pos

    return visited

def mark_visited(grid, visited):
    for r, c in visited:
        if grid[r][c] == '.':
            grid[r][c] = 'X'

def main(file_path):
    grid = read_map(file_path)
    visited = guard_patrol(grid)
    mark_visited(grid, visited)

    # Print the grid with the marked path
    for row in grid:
        print(''.join(row))

    print("Distinct positions visited:", len(visited))

if __name__ == "__main__":
    file_path = "/content/input 6part1.txt"
    main(file_path)

import sys

def pr(s):
    print(s)

# Set the recursion limit (rarely needed but might be helpful for large datasets)
sys.setrecursionlimit(10**6)

# Path to the input file
infile = '/content/input 6part2.txt'  # Path to input.txt file

# Initialize part 2 answer
p2 = 0

# Read the entire input file and split it into lines
with open(infile, 'r') as file:
    D = file.read().strip()

# Split the input into grid G
G = D.split('\n')
R = len(G)
C = len(G[0])

# Find the starting position of the guard ('^', '>', 'v', '<')
for r in range(R):
    for c in range(C):
        if G[r][c] in '^>v<':
            sr, sc = r, c

# Simulate the guard's movement for part 2
for o_r in range(R):
    for o_c in range(C):
        # Skip invalid obstruction positions (the guard's starting position or existing obstacles)
        if (o_r == sr and o_c == sc) or G[o_r][o_c] != '.':
            continue

        # Initialize guard's starting position and direction
        r, c = sr, sc
        d = {'^': 0, '>': 1, 'v': 2, '<': 3}[G[sr][sc]]  # Map direction to 0=up, 1=right, 2=down, 3=left
        SEEN = set()

        while True:
            # If the guard revisits the same position and direction, a loop is detected
            if (r, c, d) in SEEN:
                p2 += 1
                break
            SEEN.add((r, c, d))

            # Move the guard in the current direction
            dr, dc = [(-1, 0), (0, 1), (1, 0), (0, -1)][d]
            rr, cc = r + dr, c + dc

            # Check if the next position is out of bounds
            if not (0 <= rr < R and 0 <= cc < C):
                break

            # If the guard encounters an obstacle or the hypothetical obstruction, turn right
            if G[rr][cc] == '#' or (rr == o_r and cc == o_c):
                d = (d + 1) % 4
            else:
                # Otherwise, move to the next position
                r, c = rr, cc

# Output the result for part 2
pr(p2)  # Part 2 result