# -*- coding: utf-8 -*-
"""Day 24

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jzLyLVsMazC0VfjuVmwoRmqmsjw3XHGi
"""

from collections import defaultdict
import re

# Read input from file
def read_input(file_path):
    with open(file_path, 'r') as file:
        return file.read().strip().split('\n')

# Perform logic gate operations
def apply_gate(gate, a, b):
    if gate == 'AND':
        return a & b
    elif gate == 'OR':
        return a | b
    elif gate == 'XOR':
        return a ^ b
    return None

# Simulate the circuit
def simulate_circuit(lines):
    wire_values = {}
    gate_operations = []

    # Parse input
    for line in lines:
        if ':' in line:
            wire, value = line.split(': ')
            wire_values[wire] = int(value)
        else:
            gate_operations.append(line)

    # Process gates until all outputs are computed
    while gate_operations:
        remaining_operations = []
        for operation in gate_operations:
            match = re.match(r'(.+) (AND|OR|XOR) (.+) -> (.+)', operation)
            if match:
                a, gate, b, output = match.groups()
                if a in wire_values and b in wire_values:
                    wire_values[output] = apply_gate(gate, wire_values[a], wire_values[b])
                else:
                    remaining_operations.append(operation)
        gate_operations = remaining_operations

    # Collect and sort output wires starting with 'z'
    output_bits = []
    for wire, value in wire_values.items():
        if wire.startswith('z'):
            output_bits.append((wire, value))

    output_bits.sort()  # Sort to ensure correct binary order (z00, z01, ...)

    # Construct binary output
    binary_result = ''.join(str(bit[1]) for bit in output_bits[::-1])
    return int(binary_result, 2)

if __name__ == "__main__":
    input_lines = read_input("/content/input24part1.txt")
    result = simulate_circuit(input_lines)
    print("Output (Decimal):", result)

from typing import List


def parseInput() -> List[List[str]]:
    with open("/content/input24part3.txt", "r") as f:
        return [part.split("\n") for part in f.read().strip().split("\n\n")]


def find(a, b, operator, gates):
    for gate in gates:
        if gate.startswith(f"{a} {operator} {b}") or gate.startswith(
            f"{b} {operator} {a}"
        ):
            return gate.split(" -> ").pop()
    return None


def swapANDJoinWires():
    data = parseInput()
    swapped = []
    c0 = None
    for i in range(45):
        n = str(i).zfill(2)
        m1, n1, r1, z1, c1 = None, None, None, None, None

        # Half adder logic
        m1 = find(f"x{n}", f"y{n}", "XOR", data[1])
        n1 = find(f"x{n}", f"y{n}", "AND", data[1])

        if c0:
            r1 = find(c0, m1, "AND", data[1])
            if not r1:
                m1, n1 = n1, m1
                swapped.extend([m1, n1])
                r1 = find(c0, m1, "AND", data[1])

            z1 = find(c0, m1, "XOR", data[1])

            if m1 and m1.startswith("z"):
                m1, z1 = z1, m1
                swapped.extend([m1, z1])

            if n1 and n1.startswith("z"):
                n1, z1 = z1, n1
                swapped.extend([n1, z1])

            if r1 and r1.startswith("z"):
                r1, z1 = z1, r1
                swapped.extend([r1, z1])

            c1 = find(r1, n1, "OR", data[1])

        if c1 and c1.startswith("z") and c1 != "z45":
            c1, z1 = z1, c1
            swapped.extend([c1, z1])

        c0 = c1 if c0 else n1

    return ",".join(sorted(swapped))


print("Part 2", swapANDJoinWires())